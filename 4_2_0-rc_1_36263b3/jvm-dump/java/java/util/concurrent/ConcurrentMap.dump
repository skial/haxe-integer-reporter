@:realPath("java.util.concurrent.ConcurrentMap") @:used @:native("java.util.concurrent.ConcurrentMap") @:libType
extern interface java.util.concurrent.ConcurrentMap<K:Dynamic, V:Dynamic> implements java.util.Map<java.util.concurrent.ConcurrentMap.K, java.util.concurrent.ConcurrentMap.V> {

	function getOrDefault(param1:Dynamic, param2:java.util.concurrent.ConcurrentMap.V):java.util.concurrent.ConcurrentMap.V;

	function forEach(param1:java.util.function.BiConsumer<Dynamic, Dynamic>):Void;

	function putIfAbsent(param1:java.util.concurrent.ConcurrentMap.K, param2:java.util.concurrent.ConcurrentMap.V):java.util.concurrent.ConcurrentMap.V;

	function remove(param1:Dynamic, param2:Dynamic):Bool;

	function replace(param1:java.util.concurrent.ConcurrentMap.K, param2:java.util.concurrent.ConcurrentMap.V, param3:java.util.concurrent.ConcurrentMap.V):Bool;

	function replace(param1:java.util.concurrent.ConcurrentMap.K, param2:java.util.concurrent.ConcurrentMap.V):java.util.concurrent.ConcurrentMap.V;

	function replaceAll(param1:java.util.function.BiFunction<Dynamic, Dynamic, java.util.concurrent.ConcurrentMap.V>):Void;

	function computeIfAbsent(param1:java.util.concurrent.ConcurrentMap.K, param2:java.util.function.Function<Dynamic, java.util.concurrent.ConcurrentMap.V>):java.util.concurrent.ConcurrentMap.V;

	function computeIfPresent(param1:java.util.concurrent.ConcurrentMap.K, param2:java.util.function.BiFunction<Dynamic, Dynamic, java.util.concurrent.ConcurrentMap.V>):java.util.concurrent.ConcurrentMap.V;

	function compute(param1:java.util.concurrent.ConcurrentMap.K, param2:java.util.function.BiFunction<Dynamic, Dynamic, java.util.concurrent.ConcurrentMap.V>):java.util.concurrent.ConcurrentMap.V;

	function merge(param1:java.util.concurrent.ConcurrentMap.K, param2:java.util.concurrent.ConcurrentMap.V, param3:java.util.function.BiFunction<Dynamic, Dynamic, java.util.concurrent.ConcurrentMap.V>):java.util.concurrent.ConcurrentMap.V;
}