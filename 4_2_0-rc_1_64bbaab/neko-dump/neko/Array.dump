@:directlyUsed @:used @:coreApi
class Array<T> {

	public function new() {
		this.__a = __dollar__amake(0);
		this.length = 0;
	}

	var __a:neko.NativeArray<Array.T>;

	@:maybeUsed
	public var length(default,null):Int;

	public function concat(a:Array<Array.T>) {
		var a1 = this.__a;
		var a2 = a.__a;
		var s1 = this.length;
		var s2 = a.length;
		var a = __dollar__amake(s1 + s2);
		__dollar__ablit(a, 0, a1, 0, s1);
		__dollar__ablit(a, s1, a2, 0, s2);
		return Array.new1(a, s1 + s2);
	}

	public function copy() {
		var a = this.__a;
		var len = this.length;
		return Array.new1(__dollar__asub(a, 0, len), this.length);
	}

	@:maybeUsed
	public inline function iterator() {
		return new haxe.iterators.ArrayIterator(this);
	}

	public inline function keyValueIterator() {
		return new haxe.iterators.ArrayKeyValueIterator(this);
	}

	public function insert(pos:Int, x:Array.T) {
		var l = this.length;
		if ((pos < 0)) {
			pos = l + pos;
			if ((pos < 0)) pos = 0;
		};
		if ((pos > l)) pos = l;
		this.__grow(l + 1);
		var a = this.__a;
		__dollar__ablit(a, pos + 1, a, pos, l - pos);
		a[pos] = x;
	}

	public function join(sep:String) {
		var s = new StringBuf();
		var a = this.__a;
		var max = this.length - 1;
		{
			var _g = 0;
			var _g1 = this.length;
			while ((_g < _g1)) {
				var p = _g ++;
				StringBuf.__add(s.b, a[p]);
				if ((p != max)) StringBuf.__add(s.b, sep);
			};
		};
		return new String(StringBuf.__to_string(s.b));
	}

	public function toString() {
		if ((Array.__hx_toString_depth >= 5)) return "...";
		var s = new StringBuf();
		StringBuf.__add(s.b, "[");
		var it_current = 0;
		var it_array = this;
		Array.__hx_toString_depth ++;
		try {
			while ((it_current < it_array.length)) {
				var i = it_array[it_current ++];
				StringBuf.__add(s.b, i);
				if ((it_current < it_array.length)) StringBuf.__add_char(s.b, 44);
			};
			Array.__hx_toString_depth --;
		} catch (_g:Dynamic) {
			{
				null;
			};
			var e = cast haxe.Exception.caught(_g).unwrap();
			{
				Array.__hx_toString_depth --;
				neko.Lib.rethrow(e);
			};
		};
		StringBuf.__add(s.b, "]");
		return new String(StringBuf.__to_string(s.b));
	}

	public function pop() {
		if ((this.length == 0)) return null;
		this.length -= 1;
		var x = this.__a[this.length];
		this.__a[this.length] = null;
		return x;
	}

	public function push(x:Array.T) {
		var l = this.length;
		this.__grow(l + 1);
		this.__a[l] = x;
		return l + 1;
	}

	public function unshift(x:Array.T) {
		var l = this.length;
		this.__grow(l + 1);
		var a = this.__a;
		__dollar__ablit(a, 1, a, 0, l);
		a[0] = x;
	}

	public function remove(x:Array.T) {
		var i = 0;
		var l = this.length;
		var a = this.__a;
		while ((i < l)) {
			if ((a[i] == x)) {
				__dollar__ablit(a, i, a, i + 1, l - i - 1);
				-- l;
				this.length = l;
				a[l] = null;
				return true;
			};
			++ i;
		};
		return false;
	}

	public function contains(x:Array.T) {
		var i = 0;
		var l = this.length;
		var a = this.__a;
		while ((i < l)) {
			if ((a[i] == x)) return true;
			++ i;
		};
		return false;
	}

	public function indexOf(x:Array.T, fromIndex:Null<Int> = null) {
		var len = this.length;
		var i = if ((fromIndex != null)) fromIndex else 0;
		var a = this.__a;
		if ((i < 0)) {
			i += len;
			if ((i < 0)) i = 0;
		};
		while ((i < len)) {
			if ((a[i] == x)) return i;
			++ i;
		};
		return -1;
	}

	public function lastIndexOf(x:Array.T, fromIndex:Null<Int> = null) {
		var len = this.length;
		var i = if ((fromIndex != null)) fromIndex else len - 1;
		var a = this.__a;
		if ((i >= len)) i = len - 1 else if ((i < 0)) i += len;
		while ((i >= 0)) {
			if ((a[i] == x)) return i;
			-- i;
		};
		return -1;
	}

	public function reverse() {
		var i = 0;
		var l = this.length;
		var a = this.__a;
		var half = l >> 1;
		-- l;
		while ((i < half)) {
			var tmp = a[i];
			a[i] = a[l - i];
			a[l - i] = tmp;
			++ i;
		};
	}

	public function shift() {
		var l = this.length;
		if ((l == 0)) return null;
		var a = this.__a;
		var x = a[0];
		-- l;
		__dollar__ablit(a, 0, a, 1, l);
		a[l] = null;
		this.length = l;
		return x;
	}

	public function slice(pos:Int, end:Null<Int> = null) {
		if ((pos < 0)) {
			pos = this.length + pos;
			if ((pos < 0)) pos = 0;
		};
		if ((end == null)) end = this.length else if ((end < 0)) end = this.length + end;
		if ((end > this.length)) end = this.length;
		var len = end - pos;
		if ((len < 0)) return new Array();
		var a = this.__a;
		return Array.new1(__dollar__asub(a, pos, len), len);
	}

	public function sort(f:(Array.T, Array.T) -> Int) {
		var a = this.__a;
		var i = 0;
		var l = this.length;
		while ((i < l)) {
			var swap = false;
			var j = 0;
			var max = l - i - 1;
			while ((j < max)) {
				if ((f(a[j], a[j + 1]) > 0)) {
					var tmp = a[j + 1];
					a[j + 1] = a[j];
					a[j] = tmp;
					swap = true;
				};
				++ j;
			};
			if ((! swap)) break;
			++ i;
		};
	}

	public function splice(pos:Int, len:Int) {
		if ((len < 0)) return new Array();
		if ((pos < 0)) {
			pos = this.length + pos;
			if ((pos < 0)) pos = 0;
		};
		if ((pos > this.length)) {
			pos = 0;
			len = 0;
		} else if ((pos + len > this.length)) {
			len = this.length - pos;
			if ((len < 0)) len = 0;
		};
		var a = this.__a;
		var ret = Array.new1(__dollar__asub(a, pos, len), len);
		var end = pos + len;
		{
			var length = this.length - end;
			__dollar__ablit(a, pos, a, end, length);
		};
		this.length -= len;
		while ((-- len >= 0)) a[this.length + len] = null;
		return ret;
	}

	public inline function map<S>(f:Array.T -> map.S) {
		var l = this.length;
		var ret = Array.new1(__dollar__amake(l), l);
		{
			var _g = 0;
			var _g1 = l;
			while ((_g < _g1)) {
				var i = _g ++;
				ret[i] = f(this[i]);
			};
		};
		return ret;
	}

	public inline function filter(f:Array.T -> Bool) {
		var ret = [];
		{
			var _g = 0;
			var _g1 = this;
			while ((_g < _g1.length)) {
				var elt = _g1[_g];
				++ _g;
				if ((f(elt))) ret.push(elt);
			};
		};
		return ret;
	}

	public function resize(len:Int) {
		if ((this.length < len)) this.__set(len - 1, null) else if ((this.length > len)) {
			{
				var _g = len;
				var _g1 = this.length;
				while ((_g < _g1)) {
					var i = _g ++;
					this.__a[i] = null;
				};
			};
			this.length = len;
		};
	}

	function __get(pos:Int) {
		return this.__a[pos];
	}

	function __set(pos:Int, v:Array.T) {
		var a = this.__a;
		if ((this.length <= pos)) {
			var l = pos + 1;
			var dlen = l - __dollar__asize(a);
			if ((dlen > 0)) {
				if ((dlen == 1)) {
					this.__grow(l);
					a = this.__a;
				} else {
					a = __dollar__amake(l);
					{
						var src = this.__a;
						var length = this.length;
						__dollar__ablit(a, 0, src, 0, length);
					};
					this.__a = a;
				};
			};
			this.length = l;
		};
		a[pos] = v;
		return v;
	}

	function __grow(l:Int) {
		var a = this.__a;
		var sz = __dollar__asize(a);
		if ((sz >= l)) {
			this.length = l;
			return;
		};
		var big = sz * 3 >> 1;
		if ((big < l)) big = l;
		var a2 = __dollar__amake(big);
		{
			var length = this.length;
			__dollar__ablit(a2, 0, a, 0, length);
		};
		this.__a = a2;
		this.length = l;
	}

	function __neko() {
		var a = this.__a;
		var sz = __dollar__asize(a);
		if ((sz != this.length)) {
			var len = this.length;
			a = __dollar__asub(a, 0, len);
			this.__a = a;
		};
		return a;
	}

	static function new1<T>(a:neko.NativeArray<new1.T>, l:Int) {
		var inst = new Array();
		inst.__a = a;
		inst.length = l;
		return inst;
	}

	@:value(0)
	static var __hx_toString_depth:Int = 0;

	static function __init__() try {
		var msort = neko.Lib.load("std", "merge_sort", 3);
		Array.prototype.sort = function(cmp:Unknown<0>) {
			msort(this.__a, this.length, cmp);
		};
	} catch (_g:Dynamic) {
		{
			null;
		};
	}
}