@:keep @:directlyUsed @:used @:coreApi
class haxe.Exception extends Exception {

	public function new(message:str, previous:Null<haxe.Exception> = null, native:Null<Any> = null) {
		this.__skipStack = 0;
		super(message);
		this.__previousException = previous;
		if ((native != null && Std.isOfType(native, BaseException))) {
			this.__nativeException = @:implicitCast cast cast native;
			this.__nativeStack = haxe.NativeStackTrace.exceptionStack();
		} else {
			this.__nativeException = cast this;
			var infos = python.lib.Traceback.extract_stack();
			if ((infos.length != 0)) python.Syntax.call(python.Syntax.field(infos, "pop"), []);
			python.Syntax.call(python.Syntax.field(infos, "reverse"), []);
			this.__nativeStack = infos;
		};
	}

	public var native(get,never):Any;

	@:noCompletion
	var __nativeStack:list<haxe._Exception.PyStackItem>;

	@:value(0) @:noCompletion @:ifFeature("haxe.Exception.get_stack")
	var __skipStack:Int;

	@:noCompletion
	var __nativeException:BaseException;

	@:noCompletion
	var __previousException:Null<haxe.Exception>;

	function unwrap() {
		return @:implicitCast cast this.__nativeException;
	}

	function get_native() {
		return @:implicitCast cast this.__nativeException;
	}

	static function caught(value:Any) {
		if ((Std.isOfType(cast value, cast haxe.Exception))) return @:implicitCast cast cast value else if ((Std.isOfType(value, BaseException))) return new haxe.Exception(python.internal.UBuiltins.str(value), null, value) else return new haxe.ValueException(value, null, value);
	}

	static function thrown(value:Any) {
		if ((Std.isOfType(value, haxe.Exception))) return @:implicitCast cast cast value.get_native() else if ((Std.isOfType(value, BaseException))) return value else {
			var e = new haxe.ValueException(value);
			e.__skipStack ++;
			return @:implicitCast cast e;
		};
	}
}