@:used @:keep @:generic
class hl.types.ArrayBytes<T : hl.types.ArrayBytes.T> extends hl.types.ArrayBase {

	public function new() {
		this.size = this.length = 0;
		this.bytes = null;
	}

	var bytes:hl.BytesAccess<hl.types.ArrayBytes.T>;

	var size:Int;

	public function concat(a:hl.types.ArrayBytes<hl.types.ArrayBytes.T>) {
		var ac = new hl.types.ArrayBytes();
		ac.length = ac.size = this.length + a.length;
		var this1 = this.bytes;
		var this1 = hl._Bytes.Bytes_Impl_.alloc(ac.length << $bytes_sizebits(this1));
		ac.bytes = this1;
		var this1 = this.bytes;
		var offset = this.length << $bytes_sizebits(this1);
		hl._Bytes.Bytes_Impl_.blit(cast ac.bytes, 0, this.bytes, 0, offset);
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(cast ac.bytes, offset, a.bytes, 0, a.length << $bytes_sizebits(this1));
		return ac;
	}

	public function join(sep:String) {
		var s = new StringBuf();
		{
			var _g = 0;
			var _g1 = this.length;
			while ((_g < _g1)) {
				var i = _g ++;
				if ((i > 0)) s.add(sep);
				var this1 = this.bytes;
				s.add($bget(this1, i));
			};
		};
		return s.toString();
	}

	public function pop() {
		if ((this.length == 0)) return null;
		this.length --;
		var this1 = this.bytes;
		var pos = this.length;
		return $bget(this1, pos);
	}

	public function push(x:hl.types.ArrayBytes.T) {
		var len = this.length;
		if ((this.size == len)) this.__expand(len) else this.length ++;
		{
			var this1 = this.bytes;
			$bset(this1, len, x);
		};
		return this.length;
	}

	public function reverse() {
		var _g = 0;
		var _g1 = this.length >> 1;
		while ((_g < _g1)) {
			var i = _g ++;
			var k = this.length - 1 - i;
			var this1 = this.bytes;
			var tmp = $bget(this1, i);
			{
				var this1 = this.bytes;
				var this2 = this.bytes;
				var value = $bget(this2, k);
				$bset(this1, i, value);
			};
			{
				var this1 = this.bytes;
				$bset(this1, k, tmp);
			};
		};
	}

	public function shift() {
		if ((this.length == 0)) return null;
		var this1 = this.bytes;
		var v = $bget(this1, 0);
		this.length --;
		var tmp = cast this.bytes;
		var tmp1 = this.bytes;
		var this1 = this.bytes;
		var tmp2 = 1 << $bytes_sizebits(this1);
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(tmp, 0, tmp1, tmp2, this.length << $bytes_sizebits(this1));
		return v;
	}

	public function blit(pos:Int, src:hl.types.ArrayAccess, srcpos:Int, len:Int) {
		var src = cast src;
		if ((pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length)) throw haxe.Exception.thrown(haxe.io.Error.OutsideBounds);
		var tmp = cast this.bytes;
		var this1 = this.bytes;
		var tmp1 = pos << $bytes_sizebits(this1);
		var src = src.bytes;
		var this1 = this.bytes;
		var tmp2 = srcpos << $bytes_sizebits(this1);
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(tmp, tmp1, src, tmp2, len << $bytes_sizebits(this1));
	}

	public function slice(pos:Int, end:Null<Int> = null) {
		if ((pos < 0)) {
			pos = this.length + pos;
			if ((pos < 0)) pos = 0;
		};
		var pend;
		if ((end == null)) pend = this.length else {
			pend = end;
			if ((pend < 0)) pend += this.length;
			if ((pend > this.length)) pend = this.length;
		};
		var len = pend - pos;
		if ((len < 0)) return new hl.types.ArrayBytes();
		var a = new hl.types.ArrayBytes();
		a.length = a.size = len;
		var tmp = cast this.bytes;
		var this1 = this.bytes;
		var tmp1 = pos << $bytes_sizebits(this1);
		var this1 = this.bytes;
		a.bytes = hl._Bytes.Bytes_Impl_.sub(tmp, tmp1, len << $bytes_sizebits(this1));
		return a;
	}

	public function sort(f:(hl.types.ArrayBytes.T, hl.types.ArrayBytes.T) -> Int) {
		if (($ttype(cast null) == $ttype(0))) hl._Bytes.Bytes_Impl_.sortI32(cast this.bytes, 0, this.length, cast f) else hl._Bytes.Bytes_Impl_.sortF64(cast this.bytes, 0, this.length, cast f);
	}

	public function splice(pos:Int, len:Int) {
		if ((len < 0)) return new hl.types.ArrayBytes();
		if ((pos < 0)) {
			pos = this.length + pos;
			if ((pos < 0)) pos = 0;
		};
		if ((pos > this.length)) {
			pos = 0;
			len = 0;
		} else if ((pos + len > this.length)) {
			len = this.length - pos;
			if ((len < 0)) len = 0;
		};
		if ((len == 0)) return new hl.types.ArrayBytes();
		var ret = new hl.types.ArrayBytes();
		var tmp = cast this.bytes;
		var this1 = this.bytes;
		var tmp1 = pos << $bytes_sizebits(this1);
		var this1 = this.bytes;
		ret.bytes = hl._Bytes.Bytes_Impl_.sub(tmp, tmp1, len << $bytes_sizebits(this1));
		ret.size = ret.length = len;
		var end = pos + len;
		var tmp = cast this.bytes;
		var this1 = this.bytes;
		var tmp1 = pos << $bytes_sizebits(this1);
		var tmp2 = this.bytes;
		var this1 = this.bytes;
		var tmp3 = end << $bytes_sizebits(this1);
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(tmp, tmp1, tmp2, tmp3, this.length - end << $bytes_sizebits(this1));
		this.length -= len;
		return ret;
	}

	public function toString() {
		var b = new StringBuf();
		b.addChar(91);
		{
			var _g = 0;
			var _g1 = this.length;
			while ((_g < _g1)) {
				var i = _g ++;
				if ((i > 0)) b.addChar(44);
				var this1 = this.bytes;
				b.add($bget(this1, i));
			};
		};
		b.addChar(93);
		return b.toString();
	}

	public function unshift(x:hl.types.ArrayBytes.T) {
		if ((this.length == this.size)) this.__expand(this.length) else this.length ++;
		var tmp = cast this.bytes;
		var this1 = this.bytes;
		var tmp1 = 1 << $bytes_sizebits(this1);
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(tmp, tmp1, this.bytes, 0, this.length - 1 << $bytes_sizebits(this1));
		{
			var this1 = this.bytes;
			$bset(this1, 0, x);
		};
	}

	public function insert(pos:Int, x:hl.types.ArrayBytes.T) {
		if ((pos < 0)) {
			pos = this.length + pos;
			if ((pos < 0)) pos = 0;
		} else if ((pos > this.length)) pos = this.length;
		if ((this.length == this.size)) this.__expand(this.length) else this.length ++;
		var tmp = cast this.bytes;
		var this1 = this.bytes;
		var tmp1 = pos + 1 << $bytes_sizebits(this1);
		var tmp2 = this.bytes;
		var this1 = this.bytes;
		var tmp3 = pos << $bytes_sizebits(this1);
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(tmp, tmp1, tmp2, tmp3, this.length - pos - 1 << $bytes_sizebits(this1));
		{
			var this1 = this.bytes;
			$bset(this1, pos, x);
		};
	}

	public function contains(x:hl.types.ArrayBytes.T) {
		return this.indexOf(x, null) != -1;
	}

	public function remove(x:hl.types.ArrayBytes.T) {
		var idx = this.indexOf(x, null);
		if ((idx < 0)) return false;
		this.length --;
		var tmp = cast this.bytes;
		var this1 = this.bytes;
		var tmp1 = idx << $bytes_sizebits(this1);
		var tmp2 = this.bytes;
		var this1 = this.bytes;
		var tmp3 = idx + 1 << $bytes_sizebits(this1);
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(tmp, tmp1, tmp2, tmp3, this.length - idx << $bytes_sizebits(this1));
		return true;
	}

	public function indexOf(x:hl.types.ArrayBytes.T, fromIndex:Null<Int> = null) {
		var idx = if ((fromIndex == null)) 0 else fromIndex;
		if ((idx < 0)) {
			idx += this.length;
			if ((idx < 0)) idx = 0;
		};
		{
			var _g = idx;
			var _g1 = this.length;
			while ((_g < _g1)) {
				var i = _g ++;
				var this1 = this.bytes;
				if (($bget(this1, i) == x)) return i;
			};
		};
		return -1;
	}

	public function lastIndexOf(x:hl.types.ArrayBytes.T, fromIndex:Null<Int> = null) {
		var len = this.length;
		var i = if ((fromIndex != null)) fromIndex else len - 1;
		if ((i >= len)) i = len - 1 else if ((i < 0)) i += len;
		while ((i >= 0)) {
			var this1 = this.bytes;
			if (($bget(this1, i) == x)) return i;
			-- i;
		};
		return -1;
	}

	public function copy() {
		var a = new hl.types.ArrayBytes();
		a.length = a.size = this.length;
		var this1 = this.bytes;
		var this1 = hl._Bytes.Bytes_Impl_.alloc(this.length << $bytes_sizebits(this1));
		a.bytes = this1;
		var this1 = this.bytes;
		hl._Bytes.Bytes_Impl_.blit(cast a.bytes, 0, this.bytes, 0, this.length << $bytes_sizebits(this1));
		return a;
	}

	public function iterator() {
		return new hl.types.BytesIterator(this);
	}

	public function keyValueIterator() {
		return new hl.types.BytesKeyValueIterator(this);
	}

	public function map<S : map.S>(f:hl.types.ArrayBytes.T -> map.S) {
		var a = new hl.types.ArrayObj();
		if ((this.length > 0)) a.__expand(this.length - 1);
		{
			var _g = 0;
			var _g1 = this.length;
			while ((_g < _g1)) {
				var i = _g ++;
				{
					var this1 = a.array;
					var this2 = this.bytes;
					var value = f($bget(this2, i));
					$aset(this1, i, value);
				};
			};
		};
		return hl.types.ArrayDyn.alloc(a, true);
	}

	public function filter(f:hl.types.ArrayBytes.T -> Bool) {
		var a = new hl.types.ArrayBytes();
		{
			var _g = 0;
			var _g1 = this.length;
			while ((_g < _g1)) {
				var i = _g ++;
				var this1 = this.bytes;
				var v = $bget(this1, i);
				if ((f(v))) a.push(v);
			};
		};
		return a;
	}

	public function resize(len:Int) {
		if ((this.length < len)) this.__expand(len - 1) else if ((this.length > len)) {
			var tmp = cast this.bytes;
			var this1 = this.bytes;
			var tmp1 = len << $bytes_sizebits(this1);
			var this1 = this.bytes;
			hl._Bytes.Bytes_Impl_.fill(tmp, tmp1, this.length - len << $bytes_sizebits(this1), 0);
			this.length = len;
		};
	}

	public function getDyn(pos:Int) {
		var pos = pos;
		if ((pos >= this.length)) {
			var this1 = this.bytes;
			return $bytes_nullvalue(this1);
		};
		var this1 = this.bytes;
		return $bget(this1, pos);
	}

	public function setDyn(pos:Int, v:Dynamic) {
		var pos = pos;
		if ((pos >= this.length)) this.__expand(pos);
		{
			var this1 = this.bytes;
			var value = cast v;
			$bset(this1, pos, value);
		};
	}

	public function pushDyn(v:Dynamic) {
		return this.push(v);
	}

	public function popDyn() {
		return this.pop();
	}

	public function shiftDyn() {
		return this.shift();
	}

	public function unshiftDyn(v:Dynamic) {
		this.unshift(v);
	}

	public function insertDyn(pos:Int, v:Dynamic) {
		this.insert(pos, v);
	}

	public function containsDyn(v:Dynamic) {
		return this.contains(v);
	}

	public function removeDyn(v:Dynamic) {
		return this.remove(v);
	}

	public function sortDyn(f:(Dynamic, Dynamic) -> Int) {
		this.sort(f);
	}

	function __expand(index:Int) {
		if ((index < 0)) throw haxe.Exception.thrown("Invalid array index " + index);
		var newlen = index + 1;
		if ((newlen > this.size)) {
			var next = this.size * 3 >> 1;
			if ((next < newlen)) next = newlen;
			var this1 = this.bytes;
			var this1 = hl._Bytes.Bytes_Impl_.alloc(next << $bytes_sizebits(this1));
			var bytes2 = this1;
			var this1 = this.bytes;
			var bsize = this.length << $bytes_sizebits(this1);
			hl._Bytes.Bytes_Impl_.blit(bytes2, 0, this.bytes, 0, bsize);
			var this1 = this.bytes;
			hl._Bytes.Bytes_Impl_.fill(bytes2, bsize, (next << $bytes_sizebits(this1)) - bsize, 0);
			this.bytes = bytes2;
			this.size = next;
		};
		this.length = newlen;
	}
}